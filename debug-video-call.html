<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call Debug Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        .warning { background-color: #fff3cd; color: #856404; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            border-radius: 5px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .video-wrapper {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }
        video {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 5px;
            background: #000;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .test-item {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        .test-item.pass { border-color: #28a745; background-color: #d4edda; }
        .test-item.fail { border-color: #dc3545; background-color: #f8d7da; }
        .test-item.pending { border-color: #ffc107; background-color: #fff3cd; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¥ Video Call Debug Tool</h1>
        <p>This tool will help identify why your video call feature is not working.</p>
        
        <div class="test-grid">
            <div class="test-item pending" id="test-webrtc">
                <h4>WebRTC Support</h4>
                <p id="webrtc-result">Testing...</p>
            </div>
            <div class="test-item pending" id="test-media">
                <h4>Media Access</h4>
                <p id="media-result">Testing...</p>
            </div>
            <div class="test-item pending" id="test-pusher">
                <h4>Pusher Connection</h4>
                <p id="pusher-result">Testing...</p>
            </div>
            <div class="test-item pending" id="test-echo">
                <h4>Laravel Echo</h4>
                <p id="echo-result">Testing...</p>
            </div>
            <div class="test-item pending" id="test-turn">
                <h4>TURN Servers</h4>
                <p id="turn-result">Testing...</p>
            </div>
            <div class="test-item pending" id="test-api">
                <h4>API Endpoints</h4>
                <p id="api-result">Testing...</p>
            </div>
        </div>
        
        <div class="video-container">
            <div class="video-wrapper">
                <h4>Local Video</h4>
                <video id="local-video" autoplay muted playsinline></video>
                <p id="local-status">Not started</p>
            </div>
            <div class="video-wrapper">
                <h4>Remote Video (Simulated)</h4>
                <video id="remote-video" autoplay playsinline></video>
                <p id="remote-status">Not connected</p>
            </div>
        </div>
        
        <div style="text-align: center;">
            <button onclick="startDebugTest()">Start Complete Debug Test</button>
            <button onclick="testMediaAccess()">Test Media Access</button>
            <button onclick="testPusherConnection()">Test Pusher</button>
            <button onclick="testTurnServers()">Test TURN Servers</button>
            <button onclick="testAPIEndpoints()">Test API Endpoints</button>
            <button onclick="clearLog()">Clear Log</button>
        </div>
        
        <div class="container">
            <h3>ðŸ“Š Debug Log</h3>
            <div id="debug-log" class="log">Debug log will appear here...\n</div>
        </div>
    </div>

    <script>
        let localStream = null;
        let peerConnection = null;
        let testResults = {};
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            console.log(logMessage);
            
            const logElement = document.getElementById('debug-log');
            if (logElement) {
                const logEntry = document.createElement('div');
                logEntry.textContent = logMessage;
                logEntry.style.color = type === 'error' ? '#dc3545' : 
                                      type === 'success' ? '#28a745' : 
                                      type === 'warning' ? '#ffc107' : '#333';
                logElement.appendChild(logEntry);
                logElement.scrollTop = logElement.scrollHeight;
            }
        }
        
        function clearLog() {
            document.getElementById('debug-log').innerHTML = '';
        }
        
        function updateTestResult(testId, result, passed) {
            const testElement = document.getElementById(testId);
            const resultElement = document.getElementById(testId.replace('test-', '') + '-result');
            
            testElement.className = `test-item ${passed ? 'pass' : 'fail'}`;
            resultElement.textContent = result;
            resultElement.style.color = passed ? '#28a745' : '#dc3545';
            
            testResults[testId] = { result, passed };
        }
        
        async function startDebugTest() {
            log('ðŸš€ Starting comprehensive video call debug test...', 'info');
            clearLog();
            
            // Test 1: WebRTC Support
            await testWebRTCSupport();
            
            // Test 2: Media Access
            await testMediaAccess();
            
            // Test 3: Pusher Connection
            await testPusherConnection();
            
            // Test 4: Laravel Echo
            await testLaravelEcho();
            
            // Test 5: TURN Servers
            await testTurnServers();
            
            // Test 6: API Endpoints
            await testAPIEndpoints();
            
            // Generate summary
            generateSummary();
        }
        
        async function testWebRTCSupport() {
            log('ðŸ” Testing WebRTC support...', 'info');
            
            if (window.RTCPeerConnection) {
                updateTestResult('test-webrtc', 'âœ… Supported', true);
                log('âœ… WebRTC is supported', 'success');
                
                // Test specific WebRTC features
                const features = {
                    'RTCPeerConnection': !!window.RTCPeerConnection,
                    'getUserMedia': !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    'RTCIceCandidate': !!window.RTCIceCandidate,
                    'RTCSessionDescription': !!window.RTCSessionDescription
                };
                
                log(`WebRTC Features: ${JSON.stringify(features, null, 2)}`, 'info');
            } else {
                updateTestResult('test-webrtc', 'âŒ Not Supported', false);
                log('âŒ WebRTC is not supported', 'error');
            }
        }
        
        async function testMediaAccess() {
            log('ðŸŽ¥ Testing media access...', 'info');
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                updateTestResult('test-media', 'âœ… Access Granted', true);
                log('âœ… Media access granted', 'success');
                
                // Display local video
                const localVideo = document.getElementById('local-video');
                localVideo.srcObject = localStream;
                document.getElementById('local-status').textContent = 'Active';
                
                // Log stream details
                const tracks = localStream.getTracks();
                log(`Stream tracks: ${tracks.length}`, 'info');
                
                tracks.forEach((track, index) => {
                    log(`Track ${index}: ${track.kind} - enabled: ${track.enabled}, muted: ${track.muted}`, 'info');
                });
                
            } catch (error) {
                updateTestResult('test-media', 'âŒ Access Denied', false);
                log(`âŒ Media access failed: ${error.message}`, 'error');
                log(`Error details: ${JSON.stringify(error, null, 2)}`, 'error');
            }
        }
        
        async function testPusherConnection() {
            log('ðŸ“¡ Testing Pusher connection...', 'info');
            
            if (typeof window.Pusher === 'undefined') {
                updateTestResult('test-pusher', 'âŒ Not Loaded', false);
                log('âŒ Pusher library not loaded', 'error');
                return;
            }
            
            try {
                const pusher = new Pusher('5c02e54d01ca577ae77e', {
                    cluster: 'ap1',
                    forceTLS: true
                });
                
                pusher.connection.bind('connected', () => {
                    updateTestResult('test-pusher', 'âœ… Connected', true);
                    log('âœ… Pusher connected successfully', 'success');
                });
                
                pusher.connection.bind('error', (error) => {
                    updateTestResult('test-pusher', 'âŒ Connection Failed', false);
                    log(`âŒ Pusher connection error: ${error.message}`, 'error');
                });
                
                // Test connection timeout
                setTimeout(() => {
                    if (!testResults['test-pusher']) {
                        updateTestResult('test-pusher', 'â±ï¸ Timeout', false);
                        log('â±ï¸ Pusher connection timeout', 'warning');
                    }
                }, 5000);
                
            } catch (error) {
                updateTestResult('test-pusher', 'âŒ Error', false);
                log(`âŒ Pusher error: ${error.message}`, 'error');
            }
        }
        
        async function testLaravelEcho() {
            log('ðŸ”Š Testing Laravel Echo...', 'info');
            
            if (typeof window.Echo === 'undefined') {
                updateTestResult('test-echo', 'âŒ Not Available', false);
                log('âŒ Laravel Echo not available', 'error');
                return;
            }
            
            try {
                // Test Echo configuration
                const echoConfig = {
                    'Echo available': !!window.Echo,
                    'Pusher available': !!window.Pusher,
                    'Broadcaster': window.Echo?.broadcaster || 'unknown'
                };
                
                log(`Echo Configuration: ${JSON.stringify(echoConfig, null, 2)}`, 'info');
                
                updateTestResult('test-echo', 'âœ… Available', true);
                log('âœ… Laravel Echo is available', 'success');
                
            } catch (error) {
                updateTestResult('test-echo', 'âŒ Error', false);
                log(`âŒ Echo error: ${error.message}`, 'error');
            }
        }
        
        async function testTurnServers() {
            log('ðŸŒ Testing TURN servers...', 'info');
            
            const iceServers = [
                { urls: 'stun:stun.relay.metered.ca:80' },
                {
                    urls: 'turn:asia.relay.metered.ca:80',
                    username: '0582eeabe15281e17e922394',
                    credential: 'g7fjNoaIyTpLnkaf'
                }
            ];
            
            try {
                const pc = new RTCPeerConnection({ iceServers });
                
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log(`ICE Candidate: ${event.candidate.candidate}`, 'info');
                    }
                };
                
                pc.onicegatheringstatechange = () => {
                    log(`ICE Gathering State: ${pc.iceGatheringState}`, 'info');
                    
                    if (pc.iceGatheringState === 'complete') {
                        updateTestResult('test-turn', 'âœ… Working', true);
                        log('âœ… TURN servers working correctly', 'success');
                    }
                };
                
                pc.oniceconnectionstatechange = () => {
                    log(`ICE Connection State: ${pc.iceConnectionState}`, 'info');
                };
                
                // Create a data channel to trigger ICE gathering
                pc.createDataChannel('test');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Timeout after 10 seconds
                setTimeout(() => {
                    if (!testResults['test-turn']) {
                        updateTestResult('test-turn', 'â±ï¸ Timeout', false);
                        log('â±ï¸ TURN server test timeout', 'warning');
                    }
                }, 10000);
                
            } catch (error) {
                updateTestResult('test-turn', 'âŒ Error', false);
                log(`âŒ TURN server error: ${error.message}`, 'error');
            }
        }
        
        async function testAPIEndpoints() {
            log('ðŸ”— Testing API endpoints...', 'info');
            
            const endpoints = [
                { name: 'Video Call Offer', url: '/api/trades/1/video-call/offer', method: 'POST' },
                { name: 'Video Call Answer', url: '/api/trades/1/video-call/answer', method: 'POST' },
                { name: 'Video Call ICE', url: '/api/trades/1/video-call/ice-candidate', method: 'POST' }
            ];
            
            let successCount = 0;
            
            for (const endpoint of endpoints) {
                try {
                    const response = await fetch(endpoint.url, {
                        method: endpoint.method,
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                        },
                        body: JSON.stringify({ test: true })
                    });
                    
                    if (response.status === 401 || response.status === 403) {
                        log(`âœ… ${endpoint.name}: Endpoint exists (auth required)`, 'success');
                        successCount++;
                    } else if (response.status === 404) {
                        log(`âŒ ${endpoint.name}: Not found`, 'error');
                    } else {
                        log(`âœ… ${endpoint.name}: Status ${response.status}`, 'success');
                        successCount++;
                    }
                } catch (error) {
                    log(`âŒ ${endpoint.name}: ${error.message}`, 'error');
                }
            }
            
            if (successCount > 0) {
                updateTestResult('test-api', `âœ… ${successCount}/${endpoints.length} Working`, true);
            } else {
                updateTestResult('test-api', 'âŒ All Failed', false);
            }
        }
        
        function generateSummary() {
            log('\nðŸ“‹ DEBUG SUMMARY', 'info');
            log('================', 'info');
            
            const issues = [];
            const working = [];
            
            Object.keys(testResults).forEach(testId => {
                const result = testResults[testId];
                if (result.passed) {
                    working.push(testId.replace('test-', ''));
                } else {
                    issues.push(testId.replace('test-', ''));
                }
            });
            
            if (working.length > 0) {
                log(`âœ… Working: ${working.join(', ')}`, 'success');
            }
            
            if (issues.length > 0) {
                log(`âŒ Issues: ${issues.join(', ')}`, 'error');
                log('\nðŸ”§ RECOMMENDED FIXES:', 'warning');
                
                if (issues.includes('media')) {
                    log('- Check camera/microphone permissions', 'warning');
                    log('- Ensure HTTPS is enabled for media access', 'warning');
                }
                if (issues.includes('pusher')) {
                    log('- Verify Pusher configuration in .env', 'warning');
                    log('- Check if Pusher library is loaded', 'warning');
                }
                if (issues.includes('echo')) {
                    log('- Ensure Laravel Echo is properly initialized', 'warning');
                    log('- Check if Echo is loaded before video call code', 'warning');
                }
                if (issues.includes('turn')) {
                    log('- Verify TURN server credentials', 'warning');
                    log('- Check network connectivity to TURN servers', 'warning');
                }
                if (issues.includes('api')) {
                    log('- Check API routes are properly defined', 'warning');
                    log('- Verify authentication middleware', 'warning');
                }
            } else {
                log('ðŸŽ‰ All tests passed! Video call should be working.', 'success');
            }
        }
        
        // Auto-run tests on page load
        window.addEventListener('load', function() {
            log('ðŸš€ Video Call Debug Tool loaded', 'info');
            log('ðŸ“‹ Click "Start Complete Debug Test" to begin', 'info');
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
